---
title: "Introducing Themescura"
description: "Towards better tools for user facing customizations"
date: 2024-02-02

categories: ["draft"]
tags: ["tech", "theme", "design", "draft"]

hidden: true
---


## What it is

import ThemeManagerAstro from '../../../components/themeManager/themeManager.astro'

<ThemeManagerAstro />

You can also open themescura from the popup at the bottom right corner.

You can also visit the [customize](/customize) page of this website for a [Guide](/customize#guide) and the [Showcase](/customize#theme-showcase) for a few theme examples showcasing the variations and styles available.

Before reading the post, try to customize the look so that it matches your tastes. Remember, this post is only as beautiful as you make it. Which of course by extension applies to this entire site.

## What it does

Themescura takes a palette and generates variables that are used to style the interface. It also types the themes of the generated variables, which are used to style the Frontend.

import ThemeBasic from "./theme_basic.svg.astro";

<ThemeBasic />

You, the user, can edit the palette in real time, and the palettes and generated css variables are stored locally on the browser so that theme can be applied without loading the editor and can be edited whenever needed.

## Where can it be used

Usually a designer tests out several combinations of variables to arrive at a theme/brand and iterates over it to land on a definite design. Then it is handed over to frontend to setup the design system components and develop the interface. The evolution of the design system adds new styles and components. 

Themescura can be used to:

1. _Explore Style Space_
   Test out fonts and color combinations quickly
2. _Develop Design System_
   Once a theme has been chosen as brand identity, we can develop it's design system with our generated variables.
3. _Refine Theme_
   The generated theme and the design system can be tweaked and iterated using the same controls. The relationship between the palette and the generated variables can be tweaked.
4. _Offer User Facing Customizations_
   Which can be limited to preset themes or allow extended customizations.
   The user facing customization can be a part of the product, for example: Page builders, online marketplace themes, Blog builders, ui framework components, branding ui components such as forms, popups, notifications etc.

It can be used to allow users to pick themes, from either limited set of options to full customizability. It can also be used to offer dark/light modes, with high contrast modes as well.

## Motivation

I have always loved customization. I was introduced to its true form with Linux.

On most operating systems there is a set way of navigating and interacting with the interface. A default for _launching apps, navigating through files, handling windows, their layout, and switching between them etc._. There usually are themes,  limited to the system's ui and libraries that when used by other applications produce a native interface.

On linux, instead of a default interface, there are several "flavors", different takes on the same problems. A linux user got choice. They could _choose_ which interface or system worked the best for them, or mould those that came near. And if none did, they had the freedom to create one. [^1]

Here on the web however, _everything is allowed_. _But not everywhere_. Each page could contain different styles. Basic dark mode is offered by those who can add one, otherwise the style of a page is rather fixed. Evolving only with time. There are sites that offer a few themes to customize the appearance. There are extensions that apply custom CSS styles to websites, but they are cumbersome and require code. There are browsers, four extensions wearing a chromium trenchcoat, that offer "prepaired" styles via "boosts" https://arc.net/boosts, similar to Stylus, Stylebot etc. Although I admit the arc boosts are more thematic and also change the layout in some ways, but they will break with the next version of the website, and it will need the developer again to fix it. Also, they are there for only the most popular websites of the internet, the 

During the past few years developing frontends for websites and webapps, I noticed repeating several basic steps again and again to iterate and maintain the styles and themes. And from the learnings I devised a few guidelines for myself to manage the complexities. And after testing out and implementing the system in different places, I feel confident to present a first draft.

When asked why? I could take the easy way and answer Why not? But that would be dishonest.

The current philosophy of software design and development goes something like this:

The UX and Design folks determine the ideal layout and UX for the application, the brand styles if exist are used or new styles are developed and finally the Frontend is tasked with implementing the design. 


With a single style you can only make a website look one way.


The current customization abilities of software are limited to:

1. Dark/Light Mode
2. Primary Color Customization
3. Few customizable Colors
4. Browser based customizations via extensions
   - Stylus
   - Arc

The current tools available for designing/iterating a theme include:

1. Isolated design tools such as Color Palette pickers, font pickers, font scale makers, etc etc.
2. Variables in Figma and such, but iterating over those requires expertise in the relatively new Figma features and money (Multiple themes and styles require pro plans, I am sorry but I am poor)
3. Tools specific to frameworks, such as tailwind palette generators, bootstrap/etc themes.

Humans are not uni-themed. We don't have a single static preference. We change our opinions and tastes often. There may be strong standing takes, but the minor details of most of our preferences remain in constant flux.

There is no perfect theme. Long ago, I used to assume that there existed this elusive "one theme", that once found could be used for everything and no changes to themes would be needed.

But there is no perfect theme. To assure you, assume that you do have a perfect theme. Then everyone should use that theme, and once everyone uses that theme, then what is even the point of a theme? Everything looks somewhat the same. Bland, white and sans-serifed, filled with adds and generic flat illustrations.

Customization has been hard ever since. Could making it easier/more accessible change the way frontend and software is perceived?

Most tech folks that I talk to shy away from design/frontend for they assume they don't get it. But I suspect it is more because the tools to iterate and check whether something designed was "right"/"wrong" are very slow. The feedback mechanism is a snail.

Moreover, it seems there is a perception that for a thing to look good it has to be handed over to a designer, who will pick the perfect layout, fonts, colors etc to make it look good.

Honestly though, how many tools need a "different" brand image to be useful? And does it make sense shoving the "uniqueness" down the throats of end users who are fed up (I hope) of the extremely fast evolution of modern web/app design. 

For a sense of control. Giving options gives control. I feel more confident using a piece of software the more I feel that I am in control of it.

Every website should be customizable. This one is a personal dream. And by every website I mean every-fucking-website.

The problems with current customization.

A person who:
- Doesn't know the details of color theory
- Doesn't know the details of typography
- But can still determine by looking at something whether the font/colors make sense

So that I can automate the way I design themes. I have designed several websites and applications and I have found that I can create the themes/styles/brand by defining the base parameters and then how everything else is defined related to them. Similar to how palette is used to define the theme.


## How it works

![Where AI](./whereai.png)

Unfortunately, to the disappointment of several, there is no AI underneath. 

Everything starts with the palette.

The palette is used to generate the colors.

Note that the structure of the function could be anything, we can generate a lot of css variables dependent on each other, spacings, border radius, etc. We could have several naming schemes for a list of variables for example: _1. TShirt sizes_ (sm, md, base/regular, lg, xl, xxl ...) _2. Numeric_ (1,2,3) (100-200-900), and different scaling mechanisms: _1. Linear_ (2, 4, 6, 8, 10) _2. Geometric_ (2, 4, 8, 16, 32) etc.

The colors are constructed from the palette. Sometimes multiple are combined, sometimes they are lightend, brightened etc. 

import ColorLinear from './color_linear.svg.astro';

<ColorLinear />

As we don't have the linear color mixing, the colors have to be mixed step by step. We can have intermediary colors:

import ColorMixed from './color_mixed.svg.astro';

<ColorMixed />

The intermediary above is called `midErth` in code.

The generated theme object consists of the set of css variables and their values in the nested object.

We could use this theme object directly to theme our css if we were using css in js, however, every time we change this object, the styles have to then be regenerated for every change. A better way would be to have a theme object that had instead of values, just "pointers" to the changing variables. Which are CSS Variables.

So instead of using the generated theme with direct values we use another generated object that instead of having the values, we have css variables that will have those values.

We separate the structure and the theme's values so we can change the values, and only care about it's structure during usage. The generated css variables are inserted in a single style tag and are applied to the root.



Nested themes can also be declared in between via setting the variables on the parent element that will nest the objects that require the custom theme. An example of using different themes in children can be found in the examples shared in [Dark Modes](/blag/posts/dark-modes) blog post.



### Apply and Edit

It should be obvious that we should not load the theme editor every single time for every single page.

We separate the code that is needed for applying the theme and for editing the theme.

The application of the theme on page load happens by very small JS script.

The editor is written with SolidJS to piggyback on the reactive system. The reactive state is replicated in localstorage and thus can be set and then used by the applying script.



## What can be improved

A lot honestly.

First there are the bugs. The slight glitch when loading the font. The broken themes of the cached browser pages revealed on back/forward navigation.

There could be separate font families for different portions of the website, for example, a heading font and a post content font family.

Although typescript helps a lot as the theme gets typed, using css variables by hand results in hard to maintain code, which could be improved by improving the developer tooling.

There could be checks to ensure contrast ratios for the text and background and surface colors.

There could be more intuitive controls in the form of contrast, saturation and tint etc instead of the five colors only.

There could be component specific styles defined in the generated theme as well.

The icons are fixed for now and it is hard to have a 1:1 icon pack replacements like we have 1:1 font replacements for most alphanumeric characters. 

The themes could be pooled in a shared "registry", allowing people to share the themes with each other. (The current size of the palette is short enough to be shared just by copy pasting it's JSON).

User defined preferences/palette could be shared across websites, so the user could theme multiple websites using their preferred palette of colors and fonts.

More importantly there could be a representation of the theme generation step: how the palette effects the generated variables. Preferably in the form of a node graph editor instead of scripting it in code.

People have created tools to customize their themes on linux such that the colors match their wallpapers. Something similar also exists on Android. Mac blurs the background a little.


## What changes

The idea that a website's theme is static. The idea that user facing customization is hard.  The idea that to allow customization we need to save the themes/preferences on the server.

It is one step in many towards better interfaces.

---

[^1]: There are themes for linux as well but different "flavors" are themed a little differently. 
